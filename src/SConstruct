# Multiplatform
# Quake3e SCons Compiling setup
# :::::::::::::::::::::::::::::
# Based on: Quake3 Unix Makefile 
#         | Nov '98 | Zoid <zoid@idsoftware.com>
#         | Loki Hacking by Bernd Kreimeier
#                           Ryan C. Gordon
#                           Rafael Barrero
#                           ioq3 cr3w
# Ported to SCons by:
#   2022 | sOkam! for Opensource Defrag
#
#::::::::::::::::::::::::::::::::::::::
# This file intends to be a multiplatform buildsystem.
# Keep that in mind if you modify it.
# SCons takes some learning, but its way more powerful than Makefiles
#   TODO: Native support for win, macos
#::::::::::::::::::::::::::::::::::::::
#
# Naming Convention:
# ::::::::::::::::::
# cur___  : Current host
# trg___  : Build target (could be cross compiling)
# rls___  : Release
# dbg___  : Debug
# env___  : Build environment
# src___  : Source code
# obj___  : Object built from source code
# __Name  : Name of X (string)
# __Dir   : Folder containing X
# sc___   : Scons related variable
# *tru*   : Related to Aliases for SCons expected values. i.e: truArch='w', scArch='win32'
# *valid* : Supported by this build system. Not valid = support is not implemented
#::::::::::::::::::::::::::::::::::::::
# Word Order:
#   Organization goes FIRST. Program organization, not idiomatic english.
#     Category -> Thing -> Differentiating Exception 
#     : catThing_excpt
#     Example:
#       English (wrong):     initialize_build_target
#       Organization first:  trgBuild_init
#::::::::::::::::::::::::::::::::::::::
# Case styling:
#   camelCase preferred 
#   PascalCase for classes/constants only, and for SCons builtin methods
#   snake_case discouraged, only for exception management
#   All-caps for SCons environment variables -only- (CCFLAGS, etc)
#     SCons variable -inputs- (defined here, passed to scons) SHOULD be named with snake case exception styling
#::::::::::::::::::::::::::::::::::::::

# Usage and Help
# :::::::::::::::
Help("""
: Action:     command              Description
::::::::::    ::::::::             ::::::::::::
                !cmd : not implemented
: Help:       scons -h             Shows this text.
: Verbose:    scons -V             Make the output of scons fully verbose: Formatting removed and nothing filtered.
              TEMP: Use V=1        until bugfix. There is a reported issue in SCons. 
: Cores:      scons -j NUM         Use NUM of cores for building. Overwrites the value set in the scripts
: Clean:      scons -c             Cleans all built targets. Doesn't remove folders.
: Build:        
    Default   scons                Builds the targets set in the `build_default` list
    Game    -> scons game           Builds only the game code (dynamic library), without the engine   (sgame, cgame, ui)
    Debug    **scons debug          Builds debug version only     (client+server+game).  Default when `build_default` is empty
    Engine    !scons engine         Builds only the engine code, without any game code
    Server    !scons server         Builds only the dedicated server code (ded), without any client code
    Release   !scons release        Builds release version only   (client+server+game)
    Distrib   !scons distribute     Cross-compiles and builds release versions for all supported platforms.
    All       !scons all            Builds all targets (including debug and release versions of both). Doesn't install
    Install   !scons install        Builds release version only, and installs it in the folder defined in the script.
              !scons install=DIR    Same as `install`, but installs directly to `DIR` instead
: Options:
    Platform  scons p=NAME         Cross-compilation for a platform different than the current host platform
                    platform=NAME   Valid names:                     # TODO: darwin, ?mingw?
                                    Win64: 'w', 'win'                : SCons 'win32':'64bit'
                                    Win32: 'w32', 'win32'            : SCons 'win32':'32bit'
                                    Linux: 'l', 'lnx', 'linux'       : SCons 'posix':'64bit'
                                    Linux: 'l32', 'lnx32', 'linux32' : SCons 'posix':'32bit'
    Arch      scons arch=NAME      Cross-compilation for an architecture other than the current host arch
                                    Don't use, unless you know what you are doing.     #TODO: x86, arm 
                                    Defaults to x86 or x86_64, if the host platform is of a different bitsize than the one provided. Else current host arch
                                    Uses SCons default names. Valid names: (64bit) 'amd64','x86_64'  (32bit) 'x86','arm'
: Configuration:
    ./scons_local.py              Allows the user to overwrite default configuration variables set it ./lib/scons_config.py
                                   Useful to make permanent changes locally, without losing progress during updates
                                   Copy the template file `./lib/skel/scons_local.py` as `./scons_local.py`, or create a new empty file
""")
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::: 
############################################################


###############
# Helpers & imports
# ::::::::::::::::::
from   os.path import exists
import sys; sys.dont_write_bytecode=True  # Do not create bytecode __pycache__ folder
import lib.helper.mingw
import lib.helper.scons as h
from lib.helper.scons import getLocal, getCur, getCli, getGlob, getBits, isVerbose
from lib.helper.scons import ARCH, PLAT, BITS, TRG, scPlatforms, BuildObject, BuildInfo
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::: 
############################################################


###############
# Configuration
# ::::::::::::::::
from lib.helper.config_scons import *

# For configuration different than the defaults, without losing changes during updates:
#   Create a new file named "scons_local.py" in the same directory as this one
#   Assign your configuration there
#   The values active in the file will overwrite any values set in lib.scons_config      
if h.exists('scons_local.py'): from scons_local import *

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::: 
############################################################


###############
# Initialization
# ::::::::::::::::
# Supported Lists
validPlatforms = ['posix', ]  #TODO: 'win32' #todo: x86', 'mingw32', 'mingw64','darwin', 'aarch64'.  They depend on the toolchain, just need specific config
validArchs     = ['x86_64',]  # amd64 defaults to x86_64, unless pecified.   #todo: 'x86', 'arm', 'arm64'
validTargets   = ['debug', ]  #TODO: 'release', 'distribute', 'engine', 'game', 'server', 'all', 'install',
# Aliases
  # Q3 renames  (not using them, keeping only as reference for future support implementation)
  # q3Platforms  = ['x86_64', 'x86', 'mingw32', 'mingw64','darwin', 'aarch64']
  # remaps:        'arm64':'aarch64',  'mingw32'+'i386':'x86',   'cygwin':'mingw32',   'arm':'aarch64'
  # q3Archs      = ['i86pc','x86','x86_64','x64']
  # remaps:        'i86pc':'x86',   'x86_64'or'x64':'x86_64'
# Other
vmArchs         = ['x86_64', 'x86', 'arm', 'aarch64'] # List of architectures compatible with vm compiling  #TEMP: Q3 names. fix this


# Define system
# ::::::::::::::
# Current system
curPlatform    = getCur(PLAT)
curArch        = getCur(ARCH) 
curBits        = getCur(BITS)
if not curPlatform or not curArch:     sys.exit(f'::ERR SCons failed to detect the host system: HOST_OS={curPlatform}, HOST_ARCH={curArch}') 
if curPlatform not in validPlatforms:  sys.exit(f'::ERR Compilation from host platform: {curPlatform}  is not currently supported') 
if curArch     not in validArchs:      sys.exit(f'::ERR Compilation from host arch: {curArch}  is not currently supported') 
## OS
posix  = bool(curPlatform in ['posix'])
win    = bool(curPlatform in ['win32'])    #todo: tools=['mingw'] during env creation, to change from msvc to mingw
mingw  = bool(curPlatform in ['mingw'])    #TODO: How to set this value correctly? There is no mingw platform
#darwin = bool(curPlatform in ['darwin'])
#arm    = bool(curPlatform in ['arm'])
#arm64  = bool(curPlatform in ['arm64'])

# CLI System
cliPlatform = getCli(PLAT)   # Gets the converted value, not the raw alias input in `p=` or `platform=`
cliArch     = getCli(ARCH) 

# SCons setup
# ::::::::::::
## Verbose
if not isVerbose and scQuiet: SetOption('no_progress',1)  # Mute SCons progress text on non-verbose mode
if isVerbose(): Progress(': Evaluating  $TARGET\n') # SCons will echo when each file is being evaluated. TODO: Chapter 9.3
## Jobs
scJobs = max(2,int(cores*coresPc))
if cores: SetOption('num_jobs', scJobs)
## Others
Decider(scDecider) # Could be assigned per environment, but using global config instead
SConsignFile(scDir+'/scons-sign')

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::: 
############################################################


###############
# Source Code
# ::::::::::::
######################
# Client 
#::::::::
srcClient = getGlob(engineDir, clDir+'/*.c' )   # All of these are relative to the src folder. But they won't contain the folder in the string
srcServer = getGlob(engineDir, svDir+'/*.c' )   #   srcDir + clDir+'/file.c'  ==    /absolute/to/src/cldir/file.c
srcCommon = getGlob(engineDir, qcmDir+'/*.c')
srcBot    = getGlob(engineDir, botDir+'/*.c')
# Renderer
srcRendC  = getGlob(engineDir, rcDir+'/*.c')
srcRend1  = getGlob(engineDir, r1Dir+'/*.c') + srcRendC
srcRendV  = getGlob(engineDir, rvDir+'/*.c') + [f for f in srcRendC if f not in [rcDir+'/tr_image.c']]  #rendv = rendv + rendc - rendc_image (rc/tr_image.c)
# Unsupported renderer
srcRend2  = getGlob(engineDir, r2Dir+'/*.c') + srcRendC  # Disabled. Renderer2 is not used
#objRend2str = """ %s/rend2/glsl/bokeh_fp.o, ETC, ETC """ % B  #todo: How do we compile *.glsl into *.o ?
## Libraries
srcJpeg   = getGlob(engineDir, jpgDir+'/*.c')
srcSdl    = getGlob(engineDir, sdlDir+'/*.c')
## Platform Specific
srcUnix   = getGlob(engineDir, unxDir+'/*.c')
srcWin    = getGlob(engineDir, winDir+'/*.c')
## Filters: Remove
srcServer_rankings    = [svDir+'/sv_rankings.c']
srcCommon_VMplatforms = [qcmDir+'/vm_x86.c', qcmDir+'/vm_armv7l.c', qcmDir+'/vm_aarch64.c']
## Filters: Add
### Linux
srcLinux = [
  unxDir+'/unix_main.c',
  unxDir+'/unix_shared.c',
  unxDir+'/linux_signals.c',
  ]
srcLinux_nonsdl = [
  unxDir+'/linux_glimp.c', 
  unxDir+'/linux_qgl.c',
  unxDir+'/linux_snd.c',
  unxDir+'/x11_dga.c',
  unxDir+'/x11_randr.c',
  unxDir+'/x11_vidmode.c',
  ]
srcLinux_qvk = [unxDir+'/linux_qvk.c']
### Windows
srcWin = [
  winDir+'/win_main.c',
  winDir+'/win_shared.c',
  winDir+'/win_syscon.c',
  #winDir+'/win_resource.o', #FIXME: This is a .rc file, converted to .o with windres
  ]
srcWin_nonsdl = [
  winDir+'/win_gamma.c',
  winDir+'/win_glimp.c',
  winDir+'/win_input.c',
  winDir+'/win_minimize.c',
  winDir+'/win_qgl.c',
  winDir+'/win_snd.c',
  winDir+'/win_wndproc.c',
  ]
srcWin_qvk = [winDir+'/win_qvk.c']
### VM Platforms
srcVM_x86  = [qcmDir+'/vm_x86.c']
srcVM_arm  = [qcmDir+'/vm_armv7l.c']
srcVM_aa64 = [qcmDir+'/vm_aarch64.c']
### Libraries
srcCurl = [clDir+'/cl_curl.c']
## Shared Library dependencies
srcShlib = [
  qcmDir+'/q_math.c',
  qcmDir+'/q_shared.c',
  ]

# Target Sources: Client Engine
#::::::::::::::::::::::::::::::
srcEngine_cl = [f for f in srcClient if f not in srcCurl] \
             + [f for f in srcCommon if f not in srcCommon_VMplatforms] \
             + [f for f in srcServer if f not in srcServer_rankings] \
             + srcBot \
             + srcCurl + srcSdl
## Add Platform Specific
srcEngine_cl_lnx  = srcEngine_cl + srcLinux
srcEngine_cl_win  = srcEngine_cl + srcWin
## Add Renderers
srcEngine_gl1_lnx = srcEngine_cl_lnx + srcRend1
srcEngine_gl1_win = srcEngine_cl_win + srcRend1
#srcEngine_gl2_lnx = srcEngine_cl_lnx + srcRend2 + srcRend2str
#srcEngine_gl2_win = srcEngine_cl_win + srcRend2 + srcRend2str
srcEngine_vk_lnx  = srcEngine_cl_lnx + srcRendV + srcLinux_qvk  #todo: use_vulkan_api filter needed?
srcEngine_vk_win  = srcEngine_cl_win + srcRendV + srcWin_qvk    #todo: use_vulkan_api filter needed?
if not use_opengl and not use_vulkan and not use_opengl2: sys.exit('::ERR No renderer has been defined.')
## Add VM & local libs
#if compile_VM:
#  if posix or win:       srcEngine_cl += srcVM_x86
#  if arm:                srcEngine_cl += srcVM_arm
#  if arm64:              srcEngine_cl += srcVM_aa64
#if not use_system_jpeg:  srcEngine_cl += srcJpeg  # Disabled. Always using system libraries


# Target Sources: Game Client
#:::::::::::::::::::::::::::::
srcCGame = getGlob(gameDir, cgDir+'/*.c')
## Filter: Add
srcCGame_shared = [
  sgDir+'/bg_misc.c',
  sgDir+'/bg_pmove.c',
  sgDir+'/bg_slidemove.c',
  sgDir+'/bg_lib.c',
  ]
## Filters: Apply
srcGame_cg = srcCGame + srcCGame_shared + srcShlib


# Target Sources: Game Server
#::::::::::::::::::::::::::::
srcSGame = getGlob(gameDir, sgDir+'/*.c')
## Filter: Remove
srcSGame_rankings = [sgDir+'/g_rankings.c']
## Filters: Apply
srcGame_sg = [f for f in srcSGame if f not in srcSGame_rankings] + srcShlib


# Target Sources: Game UI
#:::::::::::::::::::::::::
srcUI = getGlob(gameDir, uiDir+'/*.c')
## Filter: Add
srcUI_bg = [
  sgDir+'/bg_misc.c',
  sgDir+'/bg_lib.c',
  ]
## Filter: Remove
srcUI_rankings = [
  uiDir+'/ui_login.c',
  uiDir+'/ui_rankings.c',
  uiDir+'/ui_rankstatus.c',
  uiDir+'/ui_signup.c',
  uiDir+'/ui_specifyleague.c',
  uiDir+'/ui_spreset.c',
  ]
## Filters: Apply
srcGame_ui = [f for f in srcUI if f not in srcUI_rankings] + srcUI_bg + srcShlib

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::: 
############################################################


###############
# Construction Data
#:::::::::::::::::::

# Base: Build Data
#::::::::::::::::::
base = BuildObject()  # Don't use base.setup(). This just stores build data     # Superclass possible, but #todo(maybe)
## Output data
base.bindir   = binDir  # Folder where the binaries will be created
## Compiler
### CC FLAGS
base.ccflags  = CCFLAGS_base
base.ccflags += [
      # Default in Q3 makefile:
    '-Wall','-Wstrict-prototypes', 
    #'-Wno-unused-result', #I don't think this is needed. Mark functions as void instead??
    #'-pipe', # Used to be a performance increase back in the day. Probably unnoticeable now, and it can create issues
    #'-Wimplicit', # Default in Q3, but implied by -Wall
      # New by sOkam:
    #'-std=c89', '-Wpedantic', '-pedantic', #'-pedantic-errors', # Enforce ISO C89 standard. Probably want 99
    #'-Wdouble-promotion', # Warn when a float is treated as a double
      # Recommended in tutorial:
    #'-Wextra',#'-Werror',
    #'-Wmissing-prototypes','-Wmisleading-indentation','-Wduplicated-cond','-Wold-style-definition',
    #'-Wconversion','-Wshadow','-Winit-self','-Wfloat-equal','-Wcast-align=strict',
    #'-Wformat-overflow=2','-Wformat-truncation=2', #'-Wformat', # Implied in -Wall
    #'-fdiagnostics-format=text','-fdiagnostics-minimum-margin-width=5',#'-Wwrite-strings',
    ]
### General Defines
base.defines = DFLAGS_base
#compile_VM = True if trgArch in vmArchs else False   # Only compile VM if arch is compatible
#if not compile_VM:   #todo: fix this for vm compatibility
base.defines += ['NO_VM_COMPILED']
if baseDir:         base.defines += [f'DEFAULT_BASEDIR="{baseDir}"']
if use_vulkan_api:  base.defines += [ 'USE_VULKAN_API']
base.defines += ['BOTLIB']
### Libraries
#### Defines
# We are not using local headers at all. We use system libraries always. And we are not using dlopen versions of any
#if use_local_headers:  base.defines += ['USE_LOCAL_HEADERS=1']  #TODO: Revisit this after first rls.game playtest
base.defines += ['USE_PCRE']
base.defines += ['USE_SYSTEM_JPEG']
base.defines += ['USE_CURL']
#### Linking
base.libs     = LIBS_base     # Initialize to list (currently None)
base.libs    += ['m']         # -lm
base.ldflags  = LDFLAGS_base  # Initialize to list (currently None)
base.ldflags += ['-Wl,--gc-sections', '-fvisibility=hidden']
#### Include Paths
base.ccpath   = CCPATH_base
base.parse    = PARSE_base # Will be setup as env.ParseConfig('value')
if posix:     base.parse += ['pkg-config --silence-errors --cflags-only-I sdl2']
## Custom compiler name (non verbose)

# Linux: Build Data
#:::::::::::::::::::
lnx = BuildObject()
## Environment & System
lnx.plat = 'posix'
lnx.arch = 'x86_64'
## Compiler
lnx.defines += ['USE_ICON']
#### Linking
lnx.libs    += ['SDL2']      #TODO: Filter to only the client
lnx.libs    += ['jpeg']      #TODO: Filter to only the client
lnx.libs    += ['curl']      #TODO: Filter to only the client
lnx.libs    += ['pcre']      #TODO: Filter to only the client
lnx.libs    += ['dl']        # -ldl
lnx.ldflags += ['-Wl,--hash-style=both']
#### Include Paths
lnx.ccpath  += ['/usr/include', '/usr/local/include']  #TODO: This shouldn't be needed, but.... is it?
## Custom compiler name (non verbose)

# Windows: Build Data
#:::::::::::::::::::::
win = BuildObject()
## Environment & System
win.plat     = 'win32'
win.arch     = 'x86_64'
## Compiler
win.defines += ['USE_ICON']
#if mingw: win.defines += ['CURL_STATICLIB']  #Default    elif mingw:
# Memory addr nonsense fix
win.libs     = []
win.ldflags  = []

# def DO_WINDRES (trg, src):  #TODO: How do we add Icon, q3.manifest and the other data defined in code/win32/win_resource.rc ??
#   WINDRES_cmd -i src -o trg

# Release: Build Data
#:::::::::::::::::::::
rls = BuildObject()
## Compiler
### Compiler FLAGS
rls.ccflags += CCFLAGS_rls
rls.ccflags += [
    '-O2',                 # Perform all optimizations that do not involve a space-speed tradeoff. Default -O0
    '-fvisibility=hidden', # Make all symbols hidden, unless specified (private, static, public, etc)]
    '-s',                  # Strip all symbols from the binary
    ]  #todo: Test and research -O3 and -Ofast. Could be faster than -O2. ** ioquake3 uses -O3 and -ffast-math everywhere
rls.ctype = 'release'
### General Defines
rls.defines += ['NDEBUG']
# Memory addr nonsense fix
rls.libs     = []
rls.ldflags  = []


# Debug: Build Data
#::::::::::::::::::
dbg = BuildObject()
## Compiler
dbg.ctype = 'debug'
### Compiler FLAGS
dbg.ccflags += CCFLAGS_dbg
dbg.ccflags += [
    '-Og', # Optimize -O1, but without incompatible debugging flags. Best option for fast building + debug
    '-g3', # Generate Debug information, including all extras
    ]
### General Defines
dbg.defines += ['DEBUG', '_DEBUG']
# Memory addr nonsense fix
dbg.libs     = []
dbg.ldflags  = []


# Game Client: Build Object
#:::::::::::::::::::::::::::
cg         = base.clone()
## Source code
cg.src     = srcGame_cg
cg.srcdir  = gameDir 
# Custom compiler name (non verbose)
cg.cStr    = 'cgame_CC'
cg.lStr    = 'cgame_LD'
# Output data
cg.bintype = 'lib'
# Add defines
#cg.defines += ['CGAME']

# Linux
cgLnx = cg.merge(lnx)
cgLnx.binname = f'cgame{cgLnx.arch}'
cgLnx.defines += [f'ARCH_STRING="{cgLnx.arch}"']
cgLnx_rls = cgLnx.merge(rls)
cgLnx_dbg = cgLnx.merge(dbg)
# Windows
cgWin = cg.merge(win)
cgWin.binname = f'cgame{cgWin.arch}'
#cgWin.defines += [f'ARCH_STRING="{cgWin.arch}"']  #TODO: Fix Memory Address nonsense. This is already defined???
cgWin_rls = cgWin.merge(rls)
cgWin_dbg = cgWin.merge(dbg)

# Order SCons to setup with data
cgLnx_rls.setup()
cgLnx_dbg.setup()
cgWin_rls.setup()
cgWin_dbg.setup()


# Game Server: Build Object
#:::::::::::::::::::::::::::
sg         = base.clone()
## Source code
sg.src     = srcGame_sg
sg.srcdir  = gameDir 
# Custom compiler name (non verbose)
sg.cStr    = 'sgame_CC'
sg.lStr    = 'sgame_LD'
# Output data
sg.bintype = 'lib'
# Add defines
#sg.defines += ['QAGAME']

# Linux
sgLnx = sg.merge(lnx)
sgLnx.binname = f'qagame{sgLnx.arch}'
sgLnx.defines += [f'ARCH_STRING="{sgLnx.arch}"']
sgLnx_rls = sgLnx.merge(rls)
sgLnx_dbg = sgLnx.merge(dbg)
# Windows
sgWin = sg.merge(win)
sgWin.binname = f'qagame{sgWin.arch}'
#sgWin.defines += [f'ARCH_STRING="{sgWin.arch}"']  #TODO: Fix Memory Address nonsense. This is already defined???
sgWin_rls = sgWin.merge(rls)
sgWin_dbg = sgWin.merge(dbg)

# Order SCons to setup with data
sgLnx_rls.setup()
sgLnx_dbg.setup()
sgWin_rls.setup()
sgWin_dbg.setup()


# Game UI: Build Object
#:::::::::::::::::::::::::::
ui         = base.clone()
## Source code
ui.src     = srcGame_ui
ui.srcdir  = gameDir 
# Custom compiler name (non verbose)
ui.cStr    = 'ui_CC'
ui.lStr    = 'ui_LD'
# Output data
ui.bintype = 'lib'
# Add defines
#ui.defines += ['UI']

# Linux
uiLnx = ui.merge(lnx)
uiLnx.binname = f'ui{uiLnx.arch}'
uiLnx.defines += [f'ARCH_STRING="{uiLnx.arch}"']
uiLnx_rls = uiLnx.merge(rls)
uiLnx_dbg = uiLnx.merge(dbg)
# Windows
uiWin = sg.merge(win)
uiWin.binname = f'ui{uiWin.arch}'
#uiWin.defines += [f'ARCH_STRING="{uiWin.arch}"']  #TODO: Fix Memory Address nonsense. This is already defined???
uiWin_rls = uiWin.merge(rls)
uiWin_dbg = uiWin.merge(dbg)

# Order SCons to setup with data
uiLnx_rls.setup()
uiLnx_dbg.setup()
uiWin_rls.setup()
uiWin_dbg.setup()










## TEST Build Objects
# ::::::::::::::::::::
# Target system
trgPlatform = cliPlatform if cliPlatform else getLocal(trgPlatform, curPlatform) # Chooses cli if not empty, else script specified target, or else current host platform
## Error Management
if trgPlatform not in scPlatforms:    sys.exit(f'::ERR Trying to compile for a platform not supported by SCons: {trgPlatform}')
if trgPlatform not in validPlatforms: sys.exit(f'::ERR Trying to compile for an unsupported platform: {trgPlatform}')
## Architecture
#if arm: trgArch = 'arm'   #todo: For arm support. Overrides previous x86 assumption 
# Assumed x86/64 anytime we supply a platform. For amd64: we need to override from 'arch=' or trgArch from config, unless platform is not specified
trgArch = cliArch if cliArch else getLocal(trgArch,  curArch)  # Chooses cli if not empty, else script specified target, or else current host arch
trgBits = getBits(trgArch) if trgArch else curBits
x64 = bool(trgBits==64)  
x86 = not x64  # Opposite of x64. If we are not on 64bit, then we are on 32bit. One or the other
xCompile = True if (trgPlatform != curPlatform) or (trgArch != curArch) else False
# Platform/Architecture specific
# ::::::::::::::::::::::::::::::
trgArch_ext = None  #TODO: Remove this elsewhere
if x64:      trgArch_ext = '.x64'  
#if arm:      trgArch_ext = '.arm'
#if arm64:    trgArch_ext = '.aarch64'
ext_x64   = '.x64'
ext_arm   = '.arm'
ext_arm64 = '.aarch64'

## Definition
trgClient   = f'{cName}{trgArch_ext}'   #TODO: Move this inside the class
trgDed      = f'{dName}{trgArch_ext}'
#trgRendV    = f'{render_prefix}_vulkan_{SHLIBNAME}'
#trgRend1    = f'{render_prefix}_opengl_{SHLIBNAME}'
#trgRend2    = f'{render_prefix}_opengl2_{SHLIBNAME}'
#trgRend2str = f'{binDir}/rend2/stringify'

# TEST Engine
tst = dbg.clone()
tst.plat = trgPlatform #TODO: Temporary test
tst.arch = trgArch
# Setup TEST build
tst.src    = srcEngine_cl
tst.srcdir = engineDir 
# Custom compiler name (non verbose)
tst.cStr = 'tst_CC'
tst.lStr = 'tst_LD'
# Output data
tst.binname = f'{cName}.x64'
tst.bintype = 'bin'
# Order SCons to setup with data
#tst.setup()




# Skel Build Object
#::::::::::::::::::
skel = rls.clone()
## Environment & System
skel.plat     = '' # Target Platform. Assumes current if None
skel.arch     = '' # Target Architecture. Assumes current if None
## Source code
skel.src      = [] # List of files that will be compiled
skel.srcdir   = '' # Folder where the source code is taken from
# Output data
skel.bindir   = '' # Folder where the binaries will be created
skel.binname  = '' # Base name of the binary  `name` will become `name-x64`
skel.bintype  = '' # Output type of the file (executable or library)
## Compiler
skel.ctype    = '' # Performance type (release, debug, etc) (ctype = compiler type)
skel.ccflags += [] # Flags to append to CCFLAGS
skel.defines += [] # Flags to append to CPPDEFINES
skel.libs    += [] # Flags to append to LIBS
skel.ldflags += [] # Flags to append to LINKFLAGS
skel.ccpath  += [] # Flags to append to CCPATH
skel.parse   += [] # Will be setup as env.ParseConfig('value')
## Custom compiler name (non verbose)
skel.cStr     = '' # Format for CC compiler command. Assumes "CC" if None
skel.lStr     = '' # Format for LD compiler command. Assumes "LD" if None
## Order SCons to setup with data
#skel.setup()



#############################################################################
# DEDICATED SERVER
#############################################################################
#srcDed = """
#  # Server
#    # Missing sv_rankings.c
#  # Common
#    # Missing qcommon/puff.c
#    # Missing vm_ Platforms
#  # Botlib
#  """ % binDir

#if mingw: srcDed += srcWin
#else:     srcDed += srcLinux
#if compile_VM:
#  if trgArch in ['x86', 'x86_64']:  srcDed += srcVM_x86
#  if arm:              srcDed += srcVM_arm
#  if trgArch == 'aarch64':          srcDed += srcVM_aa64

# Server Objects
#::::::::::::::::
#DO_AS      ( binDir/ded/%.o,  asmDir/%.s )
#DO_DED_CC  ( binDir/ded/%.o,  svDir/%.c  )
#DO_DED_CC  ( binDir/ded/%.o,  qcmDir/%.c )
#DO_DED_CC  ( binDir/ded/%.o,  botDir/%.c )
## Platform Specific
#DO_DED_CC  ( binDir/ded/%.o,  unxDir/%.c )
#DO_DED_CC  ( binDir/ded/%.o,  winDir/%.c )
#DO_WINDRES ( binDir/ded/%.o,  winDir/%.rc)

# Server Binaries
#::::::::::::::::
#binDir/trgDed: objDed
#	CC_cmd -o THIS_trgFilename objDed LDFLAGS_base
#compile(lnkDir+'/'+trgDed, env=rls, cStr='DED_CC')

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::: 
############################################################


#########
# Keywords
#::::::::::::::::::
###############################

# TODO:  ?? Alias(trg) 

# Groups build, and aliases
build_server = build_server or bool(server in COMMAND_LINE_TARGETS)
trgBuildList = getCli(TRG)

# Compile Keywords
## Groups
#  debug                 # * Debug   both        # group: engine + game
#  release               # * Release both        # group: engine + game
#  game                  # - Release gamecode    # group: cgame, sgame, ui
#  all                   # - ??? Release and Debug of engine+ded+game, for target platform only

## Targets
#  engine                # - engine  bin    #  ... : engine 
#  server                # - server  bin    #  ... : ded only
#  cgame                 # - cgame   lib
#  sgame                 # - sgame   lib
#  ui                    # - ui      lib

## Target Options
# kw:  release vs  debug     # Performance types
# sc:  lnx     vs  win       # Platforms


## Keywords  : build count
#  !! TODO:   All keywords are aliases !!!
#! game       = 1plat * 3target * 1perf   =  3obj   # Release Game   locally   ** #1
#! debug      = 1plat * 5target * 1perf   =  5obj   # For development locally  ** #2 
#! game-dist  = 2plat * 3target * 1perf   =  6obj   # Mod only                 ** TOP priority
#! release    = 1plat * 5target * 1perf   =  5obj   # For best performance
#! install    = 1plat * 5target * 1perf   =  5obj   # Auto installing release
#  engine     = 1plat * 1target * 1perf   =  1obj   # Release Engine locally
#  server     = 1plat * 1target * 1perf   =  1obj   # Release Server locally
#! distribute = 2plat * 5target * 2perf   = 20obj   # Engine+mod


#  scons                 Builds the targets set in the `build_default` list
#  !scons debug          Builds debug version only     (client+server+game).  Default when `build_default` is empty
#  !scons distribute     Cross-compiles and builds release versions for all supported platforms.
#  !scons release        Builds release version only   (client+server+game)
#  !scons engine         Builds only the engine code, without any game code
#  !scons game           Builds only the game code (dynamic library), without the engine   (sgame, cgame, ui)
#  !scons server         Builds only the dedicated server code (ded), without any client code
#  !scons all            Builds all targets (including debug and release versions of both). Doesn't install
#  !scons install        Builds release version only, and installs it in the folder defined in the script.
#  !scons install=DIR    Same as `install`, but installs directly to `DIR` instead


#all: debug release
#trgAll = ['debug','release','engine','game','server']
#Alias('all', trgAll)
#Alias('release', rlsDir)  #TODO: Define the binary name properly in this call
#for it in build_default:  Default(it)  # Add every list element of build_default, to the Default targets to build (additive, doesn't replace)


#########
# Install
#::::::::::::::::::
###############################

#install: release
#	INSTALL_cmd -m 0755
#TODO: Install builder setup
#rlsInstall = compile(objInstall)
#rls.Install(rlsDir, rlsInstall)  # Install B into folder A
#rls.Alias('install', rlsDir)     # Alias Install folder as CLI target 'install'
#TODO: add  install=DIR   as an option, that compiles the release version and installs it in DIR
#instDir = getCli(INSTDIR) if getCli(INSTDIR) else instDir 
#doinstall @ instDir

#TODO:
#    Install   scons install        Builds release version only, and installs it in the folder defined in the script.
#              scons install=DIR    Same as `install`, but installs directly to `DIR` instead


# BuildInfo
#::::::::::::::::::
###############################
info = BuildInfo(name=cName, version=version, bindir=binDir, baseflags=base.ccflags, rlsflags=rls.ccflags, dbgflags=dbg.ccflags)
if not (GetOption('help') or GetOption('clean')): info.print()


# Import guard
if __name__=='__main__': import sys; sys.exit(f'::MODULE-ERROR: {__file__} is not meant to be executed on its own')
